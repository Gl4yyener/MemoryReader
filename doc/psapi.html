<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>rhodeus.windows.psapi</title>
        </head><body>
        <h1>rhodeus.windows.psapi</h1>
        <!-- Generated by Ddoc from rhodeus\memory\windows\psapi.d -->
<b>Date:</b><br>
October 3, 2013
<br><br>
<b>Authors:</b><br>
Talha Zekeriya Durmu≈ü, talhazekeriyadurmus@gmail.com
<br><br>
<b>License:</b><br>
.
<br><br>

<dl><dt><big><a name="EmptyWorkingSet"></a>BOOL <u>EmptyWorkingSet</u>(HANDLE <i>hProcess</i>);
</big></dt>
<dd>Removes as many pages as possible from the working set of the specified process.
<br><br>
<b>Params:</b><br>
<table><tr><td>HANDLE <i>hProcess</i></td>
<td><br><br>

A handle to the process. The handle must have the PROCESS_QUERY_INFORMATION or PROCESS_QUERY_LIMITED_INFORMATION access right
 and the PROCESS_SET_QUOTA access right.
 For more information, see Process Security and Access Rights<http://msdn.microsoft.com/en-us/library/windows/desktop/ms684880(v=vs.85).aspx>.</td></tr>
</table><br>

</dd>
<dt><big><a name="EnumDeviceDrivers"></a>BOOL <u>EnumDeviceDrivers</u>(LPVOID* <i>lpImageBase</i>, DWORD <i>cb</i>, DWORD* <i>lpcbNeeded</i>);
</big></dt>
<dd>Retrieves the load address for each device driver in the system.
<br><br>
<b>Params:</b><br>
<table><tr><td>LPVOID* <i>lpImageBase</i></td>
<td><br><br>

An array that receives the list of load addresses for the device drivers.</td></tr>
<tr><td>DWORD <i>cb</i></td>
<td><br><br>

The size of the <i>lpImageBase</i> array, in bytes. If the array is not large enough to store the load addresses, the <i>lpcbNeeded</i> parameter receives the required size of the array.</td></tr>
<tr><td>DWORD* <i>lpcbNeeded</i></td>
<td><br><br>

The number of bytes returned in the <i>lpImageBase</i> array.</td></tr>
</table><br>
<b>Examples:</b><br>
<pre class="d_code">
		<font color=blue>enum</font> ARRAY_SIZE = 1024;
		LPVOID[ARRAY_SIZE] drivers;
		DWORD cbNeeded;
		<font color=blue>int</font> cDrivers, i;
		<font color=blue>if</font>( <u>EnumDeviceDrivers</u>(drivers.ptr, drivers.sizeof, &amp;cbNeeded) &amp;&amp; cbNeeded &lt; drivers.sizeof){ 
			<font color=blue>char</font>[ARRAY_SIZE] szDriver;

			cDrivers = cbNeeded / drivers[0].sizeof;

			writeln(<font color=red>"There are %d drivers:"</font>, cDrivers);      
			<font color=blue>for</font> (i=0; i &lt; cDrivers; i++ ){
				<font color=blue>if</font>(GetDeviceDriverBaseName(drivers[i], szDriver.ptr, szDriver.sizeof / szDriver[0].sizeof)){
					writefln(<font color=red>"%d: %s"</font>, i+1, cstr2dstr(szDriver));
				}
			}
		}<font color=blue>else</font>{
			writeln(<font color=red>"EnumDeviceDrivers failed; array size needed is %d"</font>, cbNeeded / LPVOID.sizeof);
			<font color=blue>return</font>;
		}
</pre>
<br><br>
</dd>
<dt><big><a name="PROCESS_MEMORY_COUNTERS"></a>struct <u>PROCESS_MEMORY_COUNTERS</u>;
</big></dt>
<dd>Contains the memory statistics for a process.
<br><br>
<b>Params:</b><br>
<table><tr><td>cb</td>
<td><br><br>

The size of the structure, in bytes.</td></tr>
<tr><td>PageFaultCount</td>
<td><br><br>

The number of page faults.</td></tr>
<tr><td>PeakWorkingSetSize</td>
<td><br><br>

The peak working set size, in bytes.</td></tr>
<tr><td>WorkingSetSize</td>
<td><br><br>

The current working set size, in bytes.</td></tr>
<tr><td>QuotaPeakPagedPoolUsage</td>
<td><br><br>

The peak paged pool usage, in bytes.</td></tr>
<tr><td>QuotaPagedPoolUsage</td>
<td><br><br>

The current paged pool usage, in bytes.</td></tr>
<tr><td>QuotaPeakNonPagedPoolUsage</td>
<td><br><br>

The peak nonpaged pool usage, in bytes.</td></tr>
<tr><td>QuotaNonPagedPoolUsage</td>
<td><br><br>

The current nonpaged pool usage, in bytes.</td></tr>
<tr><td>PagefileUsage</td>
<td><br><br>

The Commit Charge value in bytes for this process. Commit Charge is the total amount of memory that the memory manager has committed for a running process.</td></tr>
<tr><td>PeakPagefileUsage</td>
<td><br><br>

The peak value in bytes of the Commit Charge during the lifetime of this process.</td></tr>
</table><br>

</dd>
<dt><big><a name="ENUM_PAGE_FILE_INFORMATION"></a>struct <u>ENUM_PAGE_FILE_INFORMATION</u>;
</big></dt>
<dd>Contains information about a pagefile.
<br><br>
<b>Params:</b><br>
<table><tr><td>cb</td>
<td><br><br>

The size of this structure, in bytes.</td></tr>
<tr><td>Reserved</td>
<td><br><br>

This member is reserved.</td></tr>
<tr><td>TotalSize</td>
<td><br><br>

The total size of the pagefile, in pages.</td></tr>
<tr><td>TotalInUse</td>
<td><br><br>

The current pagefile usage, in pages.</td></tr>
<tr><td>PeakUsage</td>
<td><br><br>

The peak pagefile usage, in pages.</td></tr>
</table><br>

</dd>
<dt><big><a name="MODULEINFO"></a>struct <u>MODULEINFO</u>;
</big></dt>
<dd>Contains the module load address, size, and entry point.
<br><br>
<b>Params:</b><br>
<table><tr><td>lpBaseOfDll</td>
<td><br><br>

The load address of the module.</td></tr>
<tr><td>SizeOfImage</td>
<td><br><br>

The size of the linear space that the module occupies, in bytes.</td></tr>
<tr><td>EntryPoint</td>
<td><br><br>

The entry point of the module.</td></tr>
</table><br>
<b>Remarks:</b><br>
The load address of a module is the same as the HMODULE value.
The information returned in the SizeOfImage and EntryPoint members comes from the module's Portable Executable (PE) header.
The module entry point is the location called during process startup, thread startup, process shutdown, and thread shutdown.
While this is not the address of the DllMain function, it should be close enough for most purposes.<br><br>

</dd>
<dt><big><a name="PERFORMANCE_INFORMATION"></a>struct <u>PERFORMANCE_INFORMATION</u>;
</big></dt>
<dd>Contains performance information.
<br><br>
<b>Params:</b><br>
<table><tr><td>cb</td>
<td><br><br>

The size of this structure, in bytes.</td></tr>
<tr><td>CommitTotal</td>
<td><br><br>

The number of pages currently committed by the system. Note that committing pages (using VirtualAlloc with MEM_COMMIT) changes this value immediately; however, the physical memory is not charged until the pages are accessed.</td></tr>
<tr><td>CommitLimit</td>
<td><br><br>

The current maximum number of pages that can be committed by the system without extending the paging file(s). This number can change if memory is added or deleted, or if pagefiles have grown, shrunk, or been added. If the paging file can be extended, this is a soft limit.</td></tr>
<tr><td>CommitPeak</td>
<td><br><br>

The maximum number of pages that were simultaneously in the committed state since the last system reboot.</td></tr>
<tr><td>PhysicalTotal</td>
<td><br><br>

The amount of actual physical memory, in pages.</td></tr>
<tr><td>PhysicalAvailable</td>
<td><br><br>

The amount of physical memory currently available, in pages. This is the amount of physical memory that can be immediately reused without having to write its contents to disk first. It is the sum of the size of the standby, free, and zero lists.</td></tr>
<tr><td>SystemCache</td>
<td><br><br>

The amount of system cache memory, in pages. This is the size of the standby list plus the system working set.</td></tr>
<tr><td>KernelTotal</td>
<td><br><br>

The sum of the memory currently in the paged and nonpaged kernel pools, in pages.</td></tr>
<tr><td>KernelPaged</td>
<td><br><br>

The memory currently in the paged kernel pool, in pages.</td></tr>
<tr><td>KernelNonpaged</td>
<td><br><br>

The memory currently in the nonpaged kernel pool, in pages.</td></tr>
<tr><td>PageSize</td>
<td><br><br>

The size of a page, in bytes.</td></tr>
<tr><td>HandleCount</td>
<td><br><br>

The current number of open handles.</td></tr>
<tr><td>ProcessCount</td>
<td><br><br>

The current number of processes.</td></tr>
<tr><td>ThreadCount</td>
<td><br><br>

The current number of threads.</td></tr>
</table><br>

</dd>
<dt><big><a name="PROCESS_MEMORY_COUNTERS_EX"></a>struct <u>PROCESS_MEMORY_COUNTERS_EX</u>;
</big></dt>
<dd>Contains extended memory statistics for a process.
<br><br>
<b>Params:</b><br>
<table><tr><td>cb</td>
<td><br><br>

The size of the structure, in bytes.</td></tr>
<tr><td>PageFaultCount</td>
<td><br><br>

The number of page faults.</td></tr>
<tr><td>PeakWorkingSetSize</td>
<td><br><br>

The peak working set size, in bytes.</td></tr>
<tr><td>WorkingSetSize</td>
<td><br><br>

The current working set size, in bytes.</td></tr>
<tr><td>QuotaPeakPagedPoolUsage</td>
<td><br><br>

The peak paged pool usage, in bytes.</td></tr>
<tr><td>QuotaPagedPoolUsage</td>
<td><br><br>

The current paged pool usage, in bytes.</td></tr>
<tr><td>QuotaPeakNonPagedPoolUsage</td>
<td><br><br>

The peak nonpaged pool usage, in bytes.</td></tr>
<tr><td>QuotaNonPagedPoolUsage</td>
<td><br><br>

The current nonpaged pool usage, in bytes.</td></tr>
<tr><td>PagefileUsage</td>
<td><br><br>

The Commit Charge value in bytes for this process. Commit Charge is the total amount of memory that the memory manager has committed for a running process.
Windows 7 and Windows Server 2008 R2 and earlier:  PagefileUsage is always zero. Check PrivateUsage instead.</td></tr>
<tr><td>PeakPagefileUsage</td>
<td><br><br>

The peak value in bytes of the Commit Charge during the lifetime of this process.</td></tr>
<tr><td>PrivateUsage</td>
<td><br><br>

Same as PagefileUsage. The Commit Charge value in bytes for this process. Commit Charge is the total amount of memory that the memory manager has committed for a running process.</td></tr>
</table><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. Rhodeus 2013</small>
        </body></html>
